<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI真人对弈 - 石头剪刀布</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    
    <style>
        :root { --nba-red: #ee2244; --nba-blue: #005bb6; --gold: #f1c40f; }
        body { margin: 0; background: #000; color: white; font-family: 'PingFang SC', sans-serif; overflow: hidden; }

        /* NBA 风格顶部记分牌 */
        #scoreboard {
            position: absolute; top: 0; left: 50%; transform: translateX(-50%);
            display: flex; background: rgba(0,0,0,0.9); border-bottom: 3px solid var(--nba-red);
            z-index: 100; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .score-box { padding: 10px 25px; text-align: center; min-width: 80px; }
        .score-box.player { border-right: 1px solid #333; }
        .score-val { font-size: 36px; font-weight: 800; color: var(--gold); line-height: 1; }
        .score-label { font-size: 10px; color: #aaa; margin-top: 4px; letter-spacing: 1px; }
        .match-info { padding: 10px 15px; background: var(--nba-red); display: flex; flex-direction: column; justify-content: center; }

        /* 设置区域 */
        #settings { position: absolute; top: 15px; right: 15px; z-index: 101; }
        select { background: #222; color: #fff; border: 1px solid #555; padding: 5px; border-radius: 4px; cursor: pointer; }

        /* 游戏主体 */
        #game-stage { width: 100vw; height: 100vh; display: flex; justify-content: center; background: #1a1a1a; }
        canvas#beauty-canvas { height: 100%; aspect-ratio: 9/16; }

        /* 浮层 UI */
        #overlay { position: absolute; inset: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; pointer-events: none; z-index: 90; }
        #countdown { font-size: 180px; font-weight: 900; color: white; text-shadow: 0 0 40px rgba(0,0,0,0.8); transition: 0.2s; }
        #speech { background: white; color: black; padding: 12px 25px; border-radius: 50px; font-weight: bold; font-size: 20px; opacity: 0; transform: translateY(20px); transition: 0.4s; }

        /* 摄像头小窗 */
        #cam-container { position: absolute; bottom: 20px; right: 20px; width: 150px; height: 200px; border: 2px solid rgba(255,255,255,0.3); border-radius: 12px; overflow: hidden; transform: rotateY(180deg); }
        video#webcam { width: 100%; height: 100%; object-fit: cover; }

        /* 加载界面 */
        #loading-screen { position: fixed; inset: 0; background: #000; z-index: 200; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .loader-bar { width: 250px; height: 4px; background: #333; margin-top: 20px; border-radius: 2px; }
        #loader-fill { width: 0%; height: 100%; background: var(--nba-red); transition: 0.3s; }
    </style>
</head>
<body>

<div id="loading-screen">
    <div style="font-size: 28px; font-weight: bold; letter-spacing: 5px;">BEAUTY AI</div>
    <div class="loader-bar"><div id="loader-fill"></div></div>
    <div id="loader-status" style="margin-top: 10px; font-size: 14px; color: #888;">正在调教资源 0%</div>
</div>

<div id="scoreboard">
    <div class="score-box player">
        <div id="u-score" class="score-val">0</div>
        <div class="score-label">PLAYER</div>
    </div>
    <div class="match-info">
        <div id="match-type" style="font-size: 14px; font-weight: bold;">BO3</div>
        <div style="font-size: 9px; opacity: 0.8;">SERIES</div>
    </div>
    <div class="score-box">
        <div id="b-score" class="score-val">0</div>
        <div class="score-label">BEAUTY</div>
    </div>
</div>

<div id="settings">
    <select id="set-limit" onchange="initGame()">
        <option value="3">3局2胜</option>
        <option value="5">5局3胜</option>
        <option value="7">7局4胜</option>
        <option value="11">11局6胜</option>
    </select>
</div>

<div id="overlay">
    <div id="countdown"></div>
    <div id="speech"></div>
</div>

<div id="game-stage">
    <canvas id="beauty-canvas"></canvas>
</div>

<div id="cam-container">
    <video id="webcam" autoplay playsinline></video>
</div>

<script>
/**
 * 架构配置区
 */
const ASSETS_CONFIG = {
    path: './assets',
    folders: {
        idle1: 1, shake: 1, rock: 1, paper: 1, scissors: 1,
        invalid: 1, win1: 1, win2: 1, lose: 1
    }
};
let gameState = {
    userScore: 0,
    beautyScore: 0,
    limit: 3,
    targetScore: 2,
    currentAction: 'idle1',
    frameIdx: 0,
    userGesture: 'none',
    isProcessing: false,
    images: {}
};

const canvas = document.getElementById('beauty-canvas');
const ctx = canvas.getContext('2d');

/**
 * 1. 资源预加载引擎
 */
async function preloadResources() {
    let total = Object.values(ASSETS_CONFIG.folders).reduce((a,b) => a+b);
    let loaded = 0;

    for (let folder in ASSETS_CONFIG.folders) {
        gameState.images[folder] = [];
        for (let i = 1; i <= ASSETS_CONFIG.folders[folder]; i++) {
            const img = new Image();
            img.src = `${ASSETS_CONFIG.path}/${folder}/frames/frame_${i.toString().padStart(3, '0')}.webp`;
            await img.decode(); 
            gameState.images[folder].push(img);
            loaded++;
            let progress = Math.floor((loaded / total) * 100);
            document.getElementById('loader-fill').style.width = progress + '%';
            document.getElementById('loader-status').innerText = `正在加载资源... ${progress}%`;
        }
    }
    document.getElementById('loading-screen').style.display = 'none';
    startRenderLoop();
    startAI();
    setTimeout(gameFlowControl, 2000);
}

/**
 * 2. 高性能渲染循环
 */
function startRenderLoop() {
    canvas.width = 720; 
    canvas.height = 1280;

    function frame() {
        const frames = gameState.images[gameState.currentAction];
        // 容错：如果当前文件夹没加载完，回退到 idle1
        const activeFrames = (frames && frames.length > 0) ? frames : gameState.images['idle1'];
        
        // 关键逻辑：获取当前帧图片
        // 使用 Math.min 确保如果 frameIdx 超过总长度，则一直停留在最后一帧
        const currentIdx = Math.min(gameState.frameIdx, activeFrames.length - 1);
        const img = activeFrames[currentIdx];

        if(img) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        }

        // 帧前进逻辑
        if (['idle1', 'shake'].includes(gameState.currentAction)) {
            // 待机和摇晃动作：循环播放
            gameState.frameIdx = (gameState.frameIdx + 1) % activeFrames.length;
        } else {
            // 出拳、胜负、无效动作：前进到最后一帧后停止增加（定格）
            if (gameState.frameIdx < activeFrames.length - 1) {
                gameState.frameIdx++;
            }
        }
        requestAnimationFrame(frame);
    }
    frame();
}
function switchAction(act) {
    gameState.currentAction = act;
    gameState.frameIdx = 0;
}

/**
 * 3. AI 手势识别逻辑
 */
function startAI() {
    // 检查浏览器是否支持媒体设备API
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        console.error('浏览器不支持媒体设备API');
        alert('您的浏览器不支持摄像头功能，请更换现代浏览器（如Chrome、Safari、微信内置浏览器）重试');
        return;
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
    
    hands.onResults(results => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            gameState.userGesture = analyzeHand(results.multiHandLandmarks[0]);
        } else {
            gameState.userGesture = 'none';
        }
    });

    const camera = new Camera(document.getElementById('webcam'), {
        onFrame: async () => { await hands.send({image: document.getElementById('webcam')}); },
        width: 480, height: 640
    });
    
    // 启动摄像头并处理可能的错误
    camera.start().catch(error => {
        console.error('启动摄像头失败:', error);
        alert('无法访问摄像头，请检查权限设置或更换浏览器重试');
    });
}
function analyzeHand(landmarks) {
    // MediaPipe 关键点索引：食指(8), 中指(12), 无名指(16), 小指(20)
    // 关节索引：食指根部(5), 中指根部(9)...
    const getIsExtended = (tip, mcp) => {
        // 计算指尖到手腕的距离 vs 关节到手腕的距离
        // 简单处理：判断指尖 Y 坐标是否显著高于（在屏幕上是数值更小）关节 Y 坐标
        return landmarks[tip].y < landmarks[mcp].y - 0.05; 
    };

    const f8 = getIsExtended(8, 6);   // 食指
    const f12 = getIsExtended(12, 10); // 中指
    const f16 = getIsExtended(16, 14); // 无名指
    const f20 = getIsExtended(20, 18); // 小指

    // 石头：所有手指都握紧
    if (!f8 && !f12 && !f16 && !f20) return 'rock';
    // 布：所有手指都伸开
    if (f8 && f12 && f16 && f20) return 'paper';
    // 剪刀：食指和中指伸开，其他握紧
    if (f8 && f12 && !f16 && !f20) return 'scissors';
    
    return 'uncertain';
}
/**
 * 4. 游戏流程主控制 (状态机)
 */
// 辅助函数：取数组中出现次数最多的元素
function getMostFrequent(arr) {
    return arr.sort((a,b) =>
          arr.filter(v => v===a).length - arr.filter(v => v===b).length
    ).pop();
}

async function gameFlowControl() {
    if (gameState.userScore >= gameState.targetScore || gameState.beautyScore >= gameState.targetScore) {
        // 最终大胜负判定
        const finalWinner = gameState.userScore > gameState.beautyScore ? 'user' : 'beauty';
        if(finalWinner === 'beauty') {
            switchAction('win2'); // 播放最终大捷动画
            speak("最终还是我赢了喔，不服气再来呀！");
        }
        return; 
    }

    // 1. 引导阶段：摇晃
    switchAction('shake');
    const countEl = document.getElementById('countdown');
    for (let i = 3; i >= 1; i--) {
        countEl.innerText = i;
        await new Promise(r => setTimeout(r, 1000));
    }
    countEl.innerText = "GO!";

    // 2. 采样用户手势 (增加采样密度)
    await new Promise(r => setTimeout(r, 200)); 
    const userChoice = gameState.userGesture;
    countEl.innerText = "";

    if (userChoice === 'none' || userChoice === 'uncertain') {
        speak("不算喔，手势没看清楚～");
        switchAction('invalid');
        await new Promise(r => setTimeout(r, 3000)); // 无效动作也定格3秒
    } else {
        const moves = ['rock', 'paper', 'scissors'];
        const beautyChoice = moves[Math.floor(Math.random() * 3)];
        
        // 3. 执行动作：此时渲染引擎会自动播放并在最后一帧定格
        switchAction(beautyChoice); 
        console.log(`对决开始：用户[${userChoice}] VS 女神[${beautyChoice}]`);

        // 4. 等待动画播放并"定格展示"
        // 延迟 1 秒等待美女做出完整动作
        await new Promise(r => setTimeout(r, 1000)); 
        
        // 执行判定
        const result = judge(userChoice, beautyChoice);
        handleResult(result);

        // 5. 关键：定格展示时间（不低于 5 秒）
        // 此时美女会一直保持在出拳的最后一帧，直到这个 Promise 结束
        await new Promise(r => setTimeout(r, 5000)); 
    }

    // 6. 结束定格，回到待机状态进入下一轮
    switchAction('idle1');
    await new Promise(r => setTimeout(r, 500)); 
    gameFlowControl();
}function judge(u, b) {
    if (u === b) return 'tie';
    if ((u === 'rock' && b === 'scissors') || (u === 'paper' && b === 'rock') || (u === 'scissors' && b === 'paper')) return 'user';
    return 'beauty';
}

function handleResult(res) {
    if (res === 'tie') {
        speak("平局！再来！");
    } else if (res === 'user') {
        gameState.userScore++;
        speak("哎呀，你赢了这局");
        switchAction('lose'); 
    } else {
        gameState.beautyScore++;
        // 核心逻辑：一局胜利 vs 最终大捷
        if (gameState.beautyScore >= gameState.targetScore) {
            speak("哈哈！我是最终冠军！");
            switchAction('win2');
        } else {
            speak("这局我赢了喔！");
            switchAction('win1');
        }
    }
    updateScoreUI();
}

/**
 * 5. 辅助功能
 */
function speak(text) {
    const s = document.getElementById('speech');
    s.innerText = text;
    s.style.opacity = 1;
    s.style.transform = 'translateY(0)';
    setTimeout(() => {
        s.style.opacity = 0;
        s.style.transform = 'translateY(20px)';
    }, 2500);
}

function updateScoreUI() {
    document.getElementById('u-score').innerText = gameState.userScore;
    document.getElementById('b-score').innerText = gameState.beautyScore;
}

function initGame() {
    gameState.limit = parseInt(document.getElementById('set-limit').value);
    gameState.targetScore = Math.ceil(gameState.limit / 2);
    gameState.userScore = 0;
    gameState.beautyScore = 0;
    document.getElementById('match-type').innerText = `BO${gameState.limit}`;
    updateScoreUI();
    speak("新对局开始，来吧！");
}

// 启动入口
window.onload = preloadResources;
</script>
</body>
</html>