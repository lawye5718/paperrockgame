<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AI女神：真人剪刀石头布</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <style>
        :root { --primary: #ff4757; --gold: #f1c40f; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; background: #000; color: white; font-family: -apple-system, system-ui; overflow: hidden; height: 100dvh; }

        /* 全屏自适应容器 */
        #game-view { position: relative; width: 100vw; height: 100dvh; display: flex; justify-content: center; align-items: center; overflow: hidden; }
        #beauty-canvas { width: 100%; height: 100%; object-fit: cover; object-position: center top; z-index: 1; }

        /* NBA 风格计分牌 (适配刘海屏) */
        #scoreboard {
            position: absolute; top: env(safe-area-inset-top, 20px); left: 15px; right: 15px;
            display: flex; background: rgba(0,0,0,0.8); border-radius: 12px; z-index: 100;
            border-bottom: 2px solid var(--primary); padding: 8px 15px;
        }
        .score-item { flex: 1; text-align: center; }
        .score-val { font-size: 32px; font-weight: 800; color: var(--gold); font-family: 'Courier New', Courier, monospace; }
        .score-label { font-size: 10px; color: #888; letter-spacing: 1px; }

        /* 浮层文字 */
        #ui-overlay { position: absolute; inset: 0; z-index: 90; display: flex; flex-direction: column; justify-content: center; align-items: center; pointer-events: none; }
        #countdown { font-size: 150px; font-weight: 900; color: #fff; text-shadow: 0 0 30px rgba(0,0,0,1); }
        #msg { background: #fff; color: #000; padding: 10px 25px; border-radius: 30px; font-weight: bold; opacity: 0; transition: 0.3s; transform: translateY(30px); }

        /* 摄像头小窗 (镜面效果) */
        #user-view { position: absolute; bottom: 30px; right: 20px; width: 110px; height: 147px; border: 2px solid #fff; border-radius: 10px; overflow: hidden; transform: rotateY(180deg); z-index: 95; }
        video#webcam { width: 100%; height: 100%; object-fit: cover; }

        /* 加载/开始 启动页 */
        #startup-screen { position: fixed; inset: 0; background: #000; z-index: 200; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; }
        .bar-bg { width: 70%; height: 4px; background: #222; border-radius: 2px; margin: 20px 0; }
        #bar-fill { width: 0%; height: 100%; background: var(--primary); transition: 0.2s; }
        button#start-trigger { display: none; padding: 16px 50px; background: var(--primary); color: #fff; border: none; border-radius: 50px; font-size: 20px; font-weight: bold; box-shadow: 0 8px 20px rgba(255, 71, 87, 0.4); }
    </style>
</head>
<body>

<div id="game-view">
    <div id="scoreboard">
        <div class="score-item"><div class="score-label">PLAYER</div><div id="u-score" class="score-val">0</div></div>
        <div style="border-left: 1px solid #444; margin: 5px 15px;"></div>
        <div class="score-item">
            <select id="limit" style="background:none; color:white; border:none; font-size:12px;" onchange="initNewGame()">
                <option value="3">3局2胜</option><option value="5">5局3胜</option><option value="11">11局6胜</option>
            </select>
            <div id="bo-title" style="color:var(--primary); font-size:14px; font-weight:bold;">BO3</div>
        </div>
        <div style="border-left: 1px solid #444; margin: 5px 15px;"></div>
        <div class="score-item"><div class="score-label">BEAUTY</div><div id="b-score" class="score-val">0</div></div>
    </div>

    <canvas id="beauty-canvas"></canvas>

    <div id="ui-overlay">
        <div id="countdown"></div>
        <div id="msg">请通过摄像头出手</div>
    </div>

    <div id="user-view"><video id="webcam" playsinline muted></video></div>
</div>

<div id="startup-screen">
    <div id="pre-load">
        <div style="font-size: 20px; letter-spacing: 5px; color: #888;">BEAUTY AI</div>
        <div class="bar-bg"><div id="bar-fill"></div></div>
        <div id="load-txt" style="font-size: 12px; color: #555;">正在同步女神数据 0%</div>
    </div>
    <button id="start-trigger" onclick="runSystem()">进入游戏</button>
</div>

<script>
/**
 * 核心逻辑：基于状态驱动的渲染引擎
 */
const CONFIG = {
    path: './assets',
    fps: 24, // 强制24帧，解决手机一闪而过的问题
    actions: {
        idle1: 1, shake: 1, rock: 1, paper: 1, scissors: 1, 
        invalid: 1, win1: 1, win2: 1, lose: 1
    },
    holdDuration: 4000 // 动作停留时间（毫秒）- 4秒满足3-5秒要求
};

let store = {
    u: 0, b: 0, limit: 3, target: 2,
    act: 'idle1', idx: 0, lastTs: 0,
    gesture: 'none', imgs: {}, loaded: false,
    actionStartTime: 0, // 记录动作开始时间
    holdingAction: false // 标记是否正在保持动作显示
};

const canvas = document.getElementById('beauty-canvas');
const ctx = canvas.getContext('2d');

// 1. 资源分流预加载
async function preload() {
    // A. 优先加载 idle 和 shake (保证基础体验)
    const priority = ['idle1', 'shake'];
    let count = 0;
    const totalP = 2; // 只有2个优先资源，每个1帧

    for (let f of priority) {
        store.imgs[f] = [];
        for (let i = 1; i <= CONFIG.actions[f]; i++) {
            const img = new Image();
            img.src = `${CONFIG.path}/${f}/frames/frame_${i.toString().padStart(3, '0')}.webp`;
            await img.decode();
            store.imgs[f].push(img);
            count++;
            let p = Math.floor((count/totalP) * 100);
            document.getElementById('bar-fill').style.width = p + '%';
            document.getElementById('load-txt').innerText = `基础资源载入 ${p}%`;
        }
    }

    // B. 解放开始按钮
    document.getElementById('pre-load').style.display = 'none';
    document.getElementById('start-trigger').style.display = 'block';

    // C. 后台静默加载其余逻辑
    const rest = ['rock','paper','scissors','invalid','win1','win2','lose'];
    for(let f of rest) {
        store.imgs[f] = [];
        for(let i=1; i<=CONFIG.actions[f]; i++) {
            const img = new Image();
            img.src = `${CONFIG.path}/${f}/frames/frame_${i.toString().padStart(3, '0')}.webp`;
            img.onload = () => store.imgs[f][i-1] = img;
        }
    }
}

// 2. 帧控制器 (Time-based rendering)
function startRenderer(ts) {
    if (!store.lastTs) store.lastTs = ts;
    const delta = ts - store.lastTs;
    const frameGap = 1000 / CONFIG.fps;

    if (delta >= frameGap) {
        const frames = store.imgs[store.act];
        if (frames && frames[store.idx % frames.length]) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(frames[store.idx % frames.length], 0, 0, canvas.width, canvas.height);
        }

        store.idx++;
        // 动作循环判定
        if (store.idx >= (frames ? frames.length : 1)) {
            // 对于单帧图片，检查是否需要保持显示
            const actionsThatHold = ['rock', 'paper', 'scissors', 'win1', 'win2', 'lose', 'invalid'];
            if (actionsThatHold.includes(store.act)) {
                if (!store.holdingAction) {
                    // 第一次播放完，开始计时保持
                    store.holdingAction = true;
                    store.actionStartTime = ts;
                }
                // 检查是否已保持足够时间
                if (ts - store.actionStartTime >= CONFIG.holdDuration) {
                    store.act = 'idle1'; 
                    store.idx = 0;
                    store.holdingAction = false;
                } else {
                    // 继续显示当前帧
                    store.idx = frames.length - 1; // 保持在最后一帧
                }
            } else if (['idle1', 'shake'].includes(store.act)) {
                store.idx = 0; // 循环播放
            } else {
                store.act = 'idle1'; 
                store.idx = 0;
            }
        }
        store.lastTs = ts - (delta % frameGap);
    }
    requestAnimationFrame(startRenderer);
}

// 3. 游戏流程控制
async function runSystem() {
    document.getElementById('startup-screen').remove();
    canvas.width = 720; canvas.height = 1280;
    
    requestAnimationFrame(startRenderer);
    initCameraAI();
    setTimeout(gameLoop, 2000);
}

async function gameLoop() {
    if (store.u >= store.target || store.b >= store.target) return;

    store.act = 'shake'; store.idx = 0;
    store.holdingAction = false; // 重置保持状态
    const countEl = document.getElementById('countdown');

    for (let i = 3; i >= 1; i--) {
        countEl.innerText = i;
        await new Promise(r => setTimeout(r, 1000));
    }
    countEl.innerText = "出！";
    
    // 等待 200ms 后采样用户手势 (增加容错)
    await new Promise(r => setTimeout(r, 200));
    const userMove = store.gesture;
    countEl.innerText = "";

    if (userMove === 'none' || userMove === 'uncertain') {
        popup("没看清楚手势喔，再来！");
        store.act = 'invalid';
        store.idx = 0;
    } else {
        const list = ['rock', 'paper', 'scissors'];
        const bMove = list[Math.floor(Math.random()*3)];
        store.act = bMove; store.idx = 0;
        
        // 判定延迟 500ms 触发，对齐出拳动作
        setTimeout(() => processLogic(userMove, bMove), 500);
    }

    // 增加等待时间以适应动作保持时长 (4000ms保持 + 1000ms缓冲)
    setTimeout(gameLoop, CONFIG.holdDuration + 1000);
}

function processLogic(u, b) {
    if (u === b) { popup("平局！不分胜负~"); return; }
    
    const win = { rock: 'scissors', paper: 'rock', scissors: 'paper' };
    if (win[u] === b) {
        store.u++;
        store.act = 'lose';
        popup("可恶...这局算你赢了！");
    } else {
        store.b++;
        if (store.b >= store.target) {
            store.act = 'win2';
            popup("我赢了整场比赛！你是我的败将咯~");
        } else {
            store.act = 'win1';
            popup("哈哈，我赢了这局！");
        }
    }
    document.getElementById('u-score').innerText = store.u;
    document.getElementById('b-score').innerText = store.b;
}

function popup(txt) {
    const m = document.getElementById('msg');
    m.innerText = txt;
    m.style.opacity = 1; m.style.transform = 'translateY(0)';
    setTimeout(() => { m.style.opacity = 0; m.style.transform = 'translateY(30px)'; }, 2500);
}

// 4. AI 驱动层
function initCameraAI() {
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.8 });
    
    hands.onResults(res => {
        if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
            const m = res.multiHandLandmarks[0];
            const getUp = (t, p) => m[t].y < m[p].y;
            const f8 = getUp(8,6), f12 = getUp(12,10), f16 = getUp(16,14), f20 = getUp(20,18);
            
            if (f8 && f12 && !f16 && !f20) store.gesture = 'scissors';
            else if (f8 && f12 && f16 && f20) store.gesture = 'paper';
            else if (!f8 && !f12 && !f16 && !f20) store.gesture = 'rock';
            else store.gesture = 'uncertain';
        } else {
            store.gesture = 'none';
        }
    });

    const camera = new Camera(document.getElementById('webcam'), {
        onFrame: async () => { await hands.send({image: document.getElementById('webcam')}); },
        width: 480, height: 640
    });
    camera.start().catch(() => alert("摄像头启动失败，请检查HTTPS或权限设置"));
}

function initNewGame() {
    store.limit = parseInt(document.getElementById('limit').value);
    store.target = Math.ceil(store.limit / 2);
    store.u = 0; store.b = 0;
    document.getElementById('u-score').innerText = 0;
    document.getElementById('b-score').innerText = 0;
    document.getElementById('bo-title').innerText = `BO${store.limit}`;
    popup("对局已重置，开始吧！");
}

window.onload = preload;
</script>
</body>
</html>