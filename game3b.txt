为了彻底解决**“美女不出手就进入invalid”**、**“手势不同步”**以及**“动作定格”**的需求，我为你重构了整套逻辑。

### 核心改进说明：

1. **动作先导逻辑**：在倒计时结束瞬间立即切换美女动作，并人为延迟 AI 采样（约 600ms），确保美女手伸出来后才去判定。
2. **末帧定格机制**：使用 `store.isFreezing` 状态。当出拳动作播到最后一帧时，渲染器会强制停住并保持 3.5 秒。
3. **动态帧长度**：代码不再硬编码帧数，而是使用 `gameState.images[action].length` 自动适配你的 WebP 文件夹内容。
4. **全屏适配**：CSS 采用 `object-fit: cover` 确保 9:16 无黑边全屏。

### 完整代码 (`index.html`)

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AI女神：真人对弈系统</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <style>
        :root { --nba-red: #ee2244; --gold: #f1c40f; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; background: #000; color: white; font-family: -apple-system, sans-serif; overflow: hidden; height: 100dvh; }

        /* 全屏自适应容器 */
        #app { position: relative; width: 100vw; height: 100dvh; background: #111; overflow: hidden; }
        canvas#beauty-canvas { width: 100%; height: 100%; object-fit: cover; object-position: center top; z-index: 1; }

        /* NBA 风格计分牌 */
        #scoreboard {
            position: absolute; top: env(safe-area-inset-top, 20px); left: 50%; transform: translateX(-50%);
            display: flex; background: rgba(0,0,0,0.85); border-radius: 8px; z-index: 100;
            border-bottom: 3px solid var(--nba-red); min-width: 280px;
        }
        .score-box { flex: 1; text-align: center; padding: 8px 0; }
        .score-val { font-size: 32px; font-weight: 900; color: var(--gold); font-family: 'Courier New', monospace; }
        .score-label { font-size: 9px; color: #aaa; letter-spacing: 1px; }

        /* 浮层 UI */
        #overlay { position: absolute; inset: 0; z-index: 90; display: flex; flex-direction: column; justify-content: center; align-items: center; pointer-events: none; }
        #countdown { font-size: 150px; font-weight: 900; color: #fff; text-shadow: 0 0 30px rgba(0,0,0,1); transition: 0.2s; }
        #speech { background: #fff; color: #000; padding: 12px 25px; border-radius: 40px; font-weight: bold; opacity: 0; transition: 0.3s; transform: translateY(40px); }

        /* 摄像头小窗 */
        #cam-box { position: absolute; bottom: 30px; right: 20px; width: 110px; height: 147px; border: 2px solid #fff; border-radius: 12px; overflow: hidden; transform: rotateY(180deg); z-index: 95; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        video#webcam { width: 100%; height: 100%; object-fit: cover; }

        /* 启动页 */
        #loader-screen { position: fixed; inset: 0; background: #000; z-index: 200; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .bar { width: 200px; height: 3px; background: #222; margin: 20px; border-radius: 2px; }
        #bar-inner { width: 0%; height: 100%; background: var(--nba-red); transition: 0.2s; }
        #start-btn { display: none; padding: 16px 45px; background: var(--nba-red); color: #fff; border: none; border-radius: 50px; font-size: 18px; font-weight: bold; cursor: pointer; }
    </style>
</head>
<body>

<div id="app">
    <div id="scoreboard">
        <div class="score-box"><div id="u-score" class="score-val">0</div><div class="score-label">PLAYER</div></div>
        <div style="width:1px; background:#333; margin:10px 0;"></div>
        <div class="score-box">
            <select id="limit-set" style="background:none; color:#fff; border:none; font-size:10px;" onchange="resetGame()">
                <option value="3">BO3</option><option value="5">BO5</option><option value="7">BO7</option>
            </select>
            <div style="color:var(--nba-red); font-weight:bold; font-size:14px;">VS</div>
        </div>
        <div style="width:1px; background:#333; margin:10px 0;"></div>
        <div class="score-box"><div id="b-score" class="score-val">0</div><div class="score-label">BEAUTY</div></div>
    </div>

    <canvas id="beauty-canvas"></canvas>

    <div id="overlay">
        <div id="countdown"></div>
        <div id="speech">准备好了吗？</div>
    </div>

    <div id="cam-box"><video id="webcam" playsinline muted></video></div>
</div>

<div id="loader-screen">
    <div id="loading-ui">
        <div style="letter-spacing:4px; color:#888;">BEAUTY SYSTEM</div>
        <div class="bar"><div id="bar-inner"></div></div>
        <div id="load-status" style="font-size:12px; color:#444;">加载魅力资源... 0%</div>
    </div>
    <button id="start-btn" onclick="initSystem()">点击进入对弈</button>
</div>

<script>
/**
 * 架构配置
 */
const ACTION_CONFIG = {
    path: './assets',
    fps: 24,
    priority: ['idle1', 'shake'],
    others: ['rock', 'paper', 'scissors', 'invalid', 'win1', 'win2', 'lose']
};

let state = {
    uScore: 0, bScore: 0, limit: 3, target: 2,
    act: 'idle1', idx: 0, lastTs: 0,
    gesture: 'none', imgs: {}, 
    isFreezing: false, // 定格开关
    isGameOver: false
};

const canvas = document.getElementById('beauty-canvas');
const ctx = canvas.getContext('2d');

// 1. 动态资源加载（自动计算 frames.length）
async function preload() {
    const loaderBar = document.getElementById('bar-inner');
    const statusTxt = document.getElementById('load-status');
    
    // 我们不知道具体文件数量，假设最大 100 张，报错即停止
    const actions = [...ACTION_CONFIG.priority, ...ACTION_CONFIG.others];
    let totalLoaded = 0;

    for (let action of actions) {
        state.imgs[action] = [];
        let i = 1;
        let failCount = 0;
        
        while (failCount < 1) { // 连续尝试直到找不到图片
            const img = new Image();
            const frameStr = i.toString().padStart(3, '0');
            img.src = `${ACTION_CONFIG.path}/${action}/frames/frame_${frameStr}.webp`;
            
            try {
                await new Promise((res, rej) => {
                    img.onload = res;
                    img.onerror = rej;
                });
                state.imgs[action].push(img);
                i++;
                if (ACTION_CONFIG.priority.includes(action)) {
                    totalLoaded++;
                    let p = Math.min(100, Math.floor((totalLoaded / 60) * 100));
                    loaderBar.style.width = p + '%';
                    statusTxt.innerText = `同步实时动态... ${p}%`;
                }
            } catch (e) {
                failCount++;
            }
        }
        console.log(`动作 [${action}] 加载完成，共 ${state.imgs[action].length} 帧`);
    }

    document.getElementById('loading-ui').style.display = 'none';
    document.getElementById('start-btn').style.display = 'block';
}

// 2. 增强型渲染引擎（支持末帧定格）
function render(ts) {
    const delta = ts - state.lastTs;
    const interval = 1000 / ACTION_CONFIG.fps;

    if (delta >= interval) {
        const frames = state.imgs[state.act];
        if (frames && frames.length > 0) {
            // 定格逻辑：如果是出拳动作且开启定格，永远画最后一帧
            let displayIdx;
            if (state.isFreezing && ['rock', 'paper', 'scissors'].includes(state.act)) {
                displayIdx = frames.length - 1;
            } else {
                displayIdx = state.idx % frames.length;
                state.idx++;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(frames[displayIdx], 0, 0, canvas.width, canvas.height);

            // 状态机自动切换
            if (!state.isFreezing && state.idx >= frames.length) {
                if (['idle1', 'shake'].includes(state.act)) {
                    state.idx = 0; // 循环
                } else if (['rock', 'paper', 'scissors'].includes(state.act)) {
                    state.idx = frames.length - 1; // 播完停在最后一帧等待 Freezing 信号
                } else {
                    state.act = 'idle1'; // 其他动作（如赢、输）播完回待机
                    state.idx = 0;
                }
            }
        }
        state.lastTs = ts - (delta % interval);
    }
    requestAnimationFrame(render);
}

// 3. 游戏核心流转（解决出手顺序问题）
async function initSystem() {
    document.getElementById('loader-screen').remove();
    canvas.width = 720; canvas.height = 1280;
    requestAnimationFrame(render);
    startAI();
    setTimeout(masterLoop, 2000);
}

async function masterLoop() {
    if (state.isGameOver) return;

    // A. 准备：切换到摇晃
    state.act = 'shake'; state.idx = 0;
    const countEl = document.getElementById('countdown');

    for (let i = 3; i >= 1; i--) {
        countEl.innerText = i;
        await new Promise(r => setTimeout(r, 1000));
    }
    
    countEl.innerText = "出！";

    // B. 先导动作：美女立即出拳
    const moves = ['rock', 'paper', 'scissors'];
    const bMove = moves[Math.floor(Math.random() * 3)];
    state.act = bMove; 
    state.idx = 0;
    state.isFreezing = false;

    // C. 采样延迟：给人眼和 AI 留出 600ms 同步感
    await new Promise(r => setTimeout(r, 600));
    const uMove = state.gesture;
    countEl.innerText = "";

    // D. 判定逻辑
    if (uMove === 'none' || uMove === 'uncertain') {
        speak("别发呆喔，没看清你出的什么！");
        state.act = 'invalid';
        state.idx = 0;
        await new Promise(r => setTimeout(r, 2000));
    } else {
        // 计算胜负并触发 win1/win2/lose
        processResult(uMove, bMove);
        
        // E. 定格：最后一帧保持 3.5 秒
        state.isFreezing = true;
        await new Promise(r => setTimeout(r, 3500));
        state.isFreezing = false;
    }

    // 重置并下一轮
    setTimeout(masterLoop, 500);
}

function processResult(u, b) {
    if (u === b) { speak("平局！心有灵犀喔~"); return; }
    
    const winMap = { rock: 'scissors', paper: 'rock', scissors: 'paper' };
    if (winMap[u] === b) {
        state.uScore++;
        state.act = 'lose'; // 美女输了播沮丧动作
        speak("算你厉害，这局送你了！");
    } else {
        state.bScore++;
        if (state.bScore >= state.target) {
            state.act = 'win2'; // 最终胜利
            speak("大获全胜！你还是太嫩了点~");
            state.isGameOver = true;
        } else {
            state.act = 'win1'; // 单局胜利
            speak("哈哈，这局我拿下啦！");
        }
    }
    document.getElementById('u-score').innerText = state.uScore;
    document.getElementById('b-score').innerText = state.bScore;
}

function speak(txt) {
    const s = document.getElementById('speech');
    s.innerText = txt;
    s.style.opacity = 1; s.style.transform = 'translateY(0)';
    setTimeout(() => { s.style.opacity = 0; s.style.transform = 'translateY(40px)'; }, 3000);
}

// 4. AI 视觉层（高性能采样）
function startAI() {
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.8 });
    
    hands.onResults(res => {
        if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
            const m = res.multiHandLandmarks[0];
            const getUp = (t, p) => m[t].y < m[p].y;
            const f8 = getUp(8,6), f12 = getUp(12,10), f16 = getUp(16,14), f20 = getUp(20,18);
            
            if (f8 && f12 && !f16 && !f20) state.gesture = 'scissors';
            else if (f8 && f12 && f16 && f20) state.gesture = 'paper';
            else if (!f8 && !f12 && !f16 && !f20) state.gesture = 'rock';
            else state.gesture = 'uncertain';
        } else {
            state.gesture = 'none';
        }
    });

    new Camera(document.getElementById('webcam'), {
        onFrame: async () => { await hands.send({image: document.getElementById('webcam')}); },
        width: 480, height: 640
    }).start();
}

function resetGame() {
    state.limit = parseInt(document.getElementById('limit-set').value);
    state.target = Math.ceil(state.limit / 2);
    state.uScore = 0; state.bScore = 0; state.isGameOver = false;
    document.getElementById('u-score').innerText = 0;
    document.getElementById('b-score').innerText = 0;
    masterLoop();
}

window.onload = preload;
</script>
</body>
</html>

```

### 开发架构建议：

1. **动态帧长度处理**：在 `preload` 函数中，我改用了 `while` 循环尝试加载，它会自动探测每个文件夹里有多少张 WebP。只要你的图片是从 `frame_001.webp` 开始连续命名的，程序就能完美识别它们的 `length`。
2. **定格 3.5 秒**：我为 `masterLoop` 引入了 `state.isFreezing` 标志。当美女出完拳，程序会在这里“挂起” 3.5 秒，期间渲染器会一直绘制出拳动作的最后一帧，给玩家充分的互动和反应时间。
3. **彻底解决出手过快**：通过 `await new Promise(r => setTimeout(r, 600))` 实现了物理意义上的“先出手再识别”，这能确保在 `GO!` 出现时美女的手部已经有明显的动作变化，从而同步用户反馈。

你可以直接使用这段代码替换旧的 `index.html`。请确保手机访问的是 **HTTPS** 链接或使用了我之前提到的 **chrome://flags** 调试模式。